from langchain_core.messages.base import BaseMessage
from state06 import State, AgentResponse
from langchain_core.messages import (
    SystemMessage,
    AIMessage,
    HumanMessage,
    RemoveMessage,
)
from langgraph.types import Command
from typing import Literal
from rich import print
import sqlite3
from langchain_openai import ChatOpenAI
from langchain.output_parsers import PydanticOutputParser
from langchain_core.prompts import PromptTemplate


llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

cursor: sqlite3.Cursor = sqlite3.connect(database="database.sqlite").cursor()


def get_database_info():
    database = []
    tables = cursor.execute(
        "SELECT name FROM sqlite_master WHERE type='table';"
    ).fetchall()
    for row in tables:
        table_name = row[0]
        temp = []
        for column in cursor.execute(f"PRAGMA table_info({table_name})"):
            temp.append(column)
        database.append({f"{table_name}": temp})
    return database
parser = PydanticOutputParser(pydantic_object=AgentResponse)
prompt = PromptTemplate(
    template="{input}\n\nGenerate structured response:\n\n{format_instructions}",
    input_variables=["input"],
    partial_variables={"format_instructions": parser.get_format_instructions()},
)

# print(get_database_info())
analyzer_prompt: str =prompt.format( input=f"""\
## Role: Data Analyst in a Research Team

You are a **Data Analyst** working within a Research Team that includes a **Critic** and a **Database Tool**. Your task is to analyze data from the database, generate insightful reports, and iteratively improve your analysis based on feedback from the Critic.

### Your Responsibilities:
- **Data Retrieval:** Access and utilize the database, whose schema is given in the format:  
  `{get_database_info()}` → `[table_name: [table_headers(info[])]]`
- **Generate Reports:** Analyze the data and prepare clear, concise, and actionable reports based on user requests.
- **Utilize Tools Effectively:**  
  - **Database Tool:** Use this tool solely to execute SQL queries and retrieve the required data.  
  - **Critic:** Submit your report for review to receive feedback and suggestions.
- **Iterate and Improve:** Refine your analysis and final report by incorporating the Critic’s feedback.

### Examples:

    {{"message": "PRAGMA table_info('table_name');", "next": "Database"}},
    {{"message": "SELECT * FROM table_name;", "next": "Database"}},
    {{"message":"Your report", "next": "Critic"}},
    {{"message": "Finalize and conclude the process and deliver the report.", "next": "END"}}

    **Important Note:**  
When invoking the Database Tool, provide **only the SQL query** without any additional instructions.
"""
)
print(analyzer_prompt)
critic_prompt: str = f"""\
## Role: Critic in a Research Team

You are a **Critic** in a Research Team that consists of a **Data Analyst**, a **Critic**, and a **Database Tool**. Your main objective is to provide constructive feedback on the reports generated by the Data Analyst, ensuring that all data insights are robust, comprehensive, and clearly communicated.

### Your Responsibilities:
- **Review Reports:** Critically evaluate the reports produced by the Data Analyst using database schema information provided in the format:  
  `{get_database_info()}` → `[table_name: [table_headers(info[])]]`
- **Identify Gaps:** Point out missing perspectives, potential oversights, or areas where additional analysis could be beneficial.
- **Suggest Improvements:** Recommend alternative analytical approaches, extra data points, or enhanced methods to improve clarity and depth.
- **Collaborate:** Ensure that your feedback is actionable and helps the Data Analyst refine their analysis effectively.

Your detailed, constructive critique is essential to enhance the quality of the final report.
"""


def Analyzer_agent(state: State) -> Command[Literal["Critic", "Database", "__end__"]]:
    print("---Analyzer_agent---")
    state["criticized"] = state.get("criticized", 0)
    state["pre"]= state.get("pre", "Critic")
    if state["criticized"] < 2:
        response = llm.invoke(
            [SystemMessage(content=analyzer_prompt)] + state["messages"]
        )
    else:
        response= llm.invoke(
            [SystemMessage(content=analyzer_prompt)]
            + state["messages"]
            + [
                HumanMessage(
                    content="Finalize and conclude the process and deliver the report."
                )
            ]
        )
    print("Analyzer_agent response:", response)
    response = parser.parse(text=str(response.content))
    if state["pre"] == "Database":
        return Command(
            update={
                "messages": [
                    AIMessage(content=response.message),
                    RemoveMessage(id=str(state["messages"][-1].id)),
                ],
            },
            goto=response.next,
        )
    return Command(
        update={"messages": [AIMessage(content=response.message)],"criticized": state["criticized"] + 1},
        goto=response.next if response.next != "END" else "__end__",
    )


def Critic_agent(state: State) -> Command[Literal["Analyst"]]:
    print("---Critic_agent---")
    response = llm.invoke(
        [SystemMessage(content=critic_prompt)] + state["messages"]
    )
    print("Critic_agent response:", response)
    response = parser.parse(text=str(response.content))
    return Command(
        update={"messages": [AIMessage(content=response.message)], "pre": "Critic"},
        goto="Analyst",
    )


def Database(state: State) -> Command[Literal["Analyst"]]:
    print("---Database_agent---")
    cursor: sqlite3.Cursor = sqlite3.connect("database.sqlite").cursor()
    response = []
    try:
        for message in cursor.execute(str(state["messages"][-1].content)).fetchall():
            response.append(str(message))
    except sqlite3.Error as e:
        response.append(f"Database error: {e}")
    return Command(
        update={"messages": [AIMessage(content=str(response))], "pre": "Database"},
        goto="Analyst",
    )
